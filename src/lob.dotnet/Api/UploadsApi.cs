/*
 * Lob
 *
 * The Lob API is organized around REST. Our API is designed to have predictable, resource-oriented URLs and uses HTTP response codes to indicate any API errors. <p> Looking for our [previous documentation](https://lob.github.io/legacy-docs/)? 
 *
 * The version of the OpenAPI document: 1.3.0
 * Contact: lob-openapi@lob.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using lob.dotnet.Client;
using System.Runtime.Serialization;
using lob.dotnet.Model;

namespace lob.dotnet.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IUploadsApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// get_export
        /// </summary>
        /// <remarks>
        /// Retrieves the details of an existing export. You need only supply the unique export identifier that was returned upon export creation. If you try retrieving an export immediately after creating one (i.e., before we&#39;re done processing the export), you will get back an export object with &#x60;state &#x3D; in_progress&#x60;.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exId">ID of the export</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Export</returns>
        Export get_export(string uplId, string exId, int operationIndex = 0);

        /// <summary>
        /// get_export
        /// </summary>
        /// <remarks>
        /// Retrieves the details of an existing export. You need only supply the unique export identifier that was returned upon export creation. If you try retrieving an export immediately after creating one (i.e., before we&#39;re done processing the export), you will get back an export object with &#x60;state &#x3D; in_progress&#x60;.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exId">ID of the export</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Export</returns>
        ApiResponse<Export> get_exportWithHttpInfo(string uplId, string exId, int operationIndex = 0);
        /// <summary>
        /// get
        /// </summary>
        /// <remarks>
        /// Retrieves the details of an existing upload. You need only supply the unique upload identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Upload</returns>
        Upload get(string uplId, int operationIndex = 0);

        /// <summary>
        /// get
        /// </summary>
        /// <remarks>
        /// Retrieves the details of an existing upload. You need only supply the unique upload identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Upload</returns>
        ApiResponse<Upload> getWithHttpInfo(string uplId, int operationIndex = 0);
        /// <summary>
        /// create
        /// </summary>
        /// <remarks>
        /// Creates a new upload with the provided properties.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadWritable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Upload</returns>
        Upload create(UploadWritable uploadWritable, int operationIndex = 0);

        /// <summary>
        /// create
        /// </summary>
        /// <remarks>
        /// Creates a new upload with the provided properties.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadWritable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Upload</returns>
        ApiResponse<Upload> createWithHttpInfo(UploadWritable uploadWritable, int operationIndex = 0);
        /// <summary>
        /// delete
        /// </summary>
        /// <remarks>
        /// Delete an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void delete(string uplId, int operationIndex = 0);

        /// <summary>
        /// delete
        /// </summary>
        /// <remarks>
        /// Delete an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> deleteWithHttpInfo(string uplId, int operationIndex = 0);
        /// <summary>
        /// create_export
        /// </summary>
        /// <remarks>
        /// Campaign Exports can help you understand exactly which records in a campaign could not be created. By initiating and retrieving an export, you will get row-by-row errors for your campaign. For a step-by-step walkthrough of creating a campaign and exporting failures, see our [Campaigns Guide](https://help.lob.com/best-practices/launching-your-first-campaign).  Create an export file associated with an upload.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exportModel"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>UploadCreateExport</returns>
        UploadCreateExport create_export(string uplId, ExportModel exportModel, int operationIndex = 0);

        /// <summary>
        /// create_export
        /// </summary>
        /// <remarks>
        /// Campaign Exports can help you understand exactly which records in a campaign could not be created. By initiating and retrieving an export, you will get row-by-row errors for your campaign. For a step-by-step walkthrough of creating a campaign and exporting failures, see our [Campaigns Guide](https://help.lob.com/best-practices/launching-your-first-campaign).  Create an export file associated with an upload.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exportModel"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of UploadCreateExport</returns>
        ApiResponse<UploadCreateExport> create_exportWithHttpInfo(string uplId, ExportModel exportModel, int operationIndex = 0);
        /// <summary>
        /// upload_file
        /// </summary>
        /// <remarks>
        /// Upload an [audience file](https://help.lob.com/best-practices/campaign-audience-guide) and associate it with an upload.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="file"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>UploadFile</returns>
        UploadFile upload_file(string uplId, Object file, int operationIndex = 0);

        /// <summary>
        /// upload_file
        /// </summary>
        /// <remarks>
        /// Upload an [audience file](https://help.lob.com/best-practices/campaign-audience-guide) and associate it with an upload.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="file"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of UploadFile</returns>
        ApiResponse<UploadFile> upload_fileWithHttpInfo(string uplId, Object file, int operationIndex = 0);
        /// <summary>
        /// update
        /// </summary>
        /// <remarks>
        /// Update the details of an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="uploadUpdatable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Upload</returns>
        Upload update(string uplId, UploadUpdatable uploadUpdatable, int operationIndex = 0);

        /// <summary>
        /// update
        /// </summary>
        /// <remarks>
        /// Update the details of an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="uploadUpdatable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Upload</returns>
        ApiResponse<Upload> updateWithHttpInfo(string uplId, UploadUpdatable uploadUpdatable, int operationIndex = 0);
        /// <summary>
        /// list
        /// </summary>
        /// <remarks>
        /// Returns a list of your uploads. Optionally, filter uploads by campaign.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="campaignId">id of the campaign (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Upload&gt;</returns>
        List<Upload> list(string campaignId = default(string), int operationIndex = 0);

        /// <summary>
        /// list
        /// </summary>
        /// <remarks>
        /// Returns a list of your uploads. Optionally, filter uploads by campaign.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="campaignId">id of the campaign (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Upload&gt;</returns>
        ApiResponse<List<Upload>> listWithHttpInfo(string campaignId = default(string), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IUploadsApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// get_export
        /// </summary>
        /// <remarks>
        /// Retrieves the details of an existing export. You need only supply the unique export identifier that was returned upon export creation. If you try retrieving an export immediately after creating one (i.e., before we&#39;re done processing the export), you will get back an export object with &#x60;state &#x3D; in_progress&#x60;.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exId">ID of the export</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Export</returns>
        System.Threading.Tasks.Task<Export> get_exportAsync(string uplId, string exId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// get_export
        /// </summary>
        /// <remarks>
        /// Retrieves the details of an existing export. You need only supply the unique export identifier that was returned upon export creation. If you try retrieving an export immediately after creating one (i.e., before we&#39;re done processing the export), you will get back an export object with &#x60;state &#x3D; in_progress&#x60;.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exId">ID of the export</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Export)</returns>
        System.Threading.Tasks.Task<ApiResponse<Export>> get_exportWithHttpInfoAsync(string uplId, string exId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// get
        /// </summary>
        /// <remarks>
        /// Retrieves the details of an existing upload. You need only supply the unique upload identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Upload</returns>
        System.Threading.Tasks.Task<Upload> getAsync(string uplId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// get
        /// </summary>
        /// <remarks>
        /// Retrieves the details of an existing upload. You need only supply the unique upload identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Upload)</returns>
        System.Threading.Tasks.Task<ApiResponse<Upload>> getWithHttpInfoAsync(string uplId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// create
        /// </summary>
        /// <remarks>
        /// Creates a new upload with the provided properties.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadWritable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Upload</returns>
        System.Threading.Tasks.Task<Upload> createAsync(UploadWritable uploadWritable, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// create
        /// </summary>
        /// <remarks>
        /// Creates a new upload with the provided properties.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadWritable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Upload)</returns>
        System.Threading.Tasks.Task<ApiResponse<Upload>> createWithHttpInfoAsync(UploadWritable uploadWritable, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// delete
        /// </summary>
        /// <remarks>
        /// Delete an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task deleteAsync(string uplId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// delete
        /// </summary>
        /// <remarks>
        /// Delete an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> deleteWithHttpInfoAsync(string uplId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// create_export
        /// </summary>
        /// <remarks>
        /// Campaign Exports can help you understand exactly which records in a campaign could not be created. By initiating and retrieving an export, you will get row-by-row errors for your campaign. For a step-by-step walkthrough of creating a campaign and exporting failures, see our [Campaigns Guide](https://help.lob.com/best-practices/launching-your-first-campaign).  Create an export file associated with an upload.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exportModel"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UploadCreateExport</returns>
        System.Threading.Tasks.Task<UploadCreateExport> create_exportAsync(string uplId, ExportModel exportModel, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// create_export
        /// </summary>
        /// <remarks>
        /// Campaign Exports can help you understand exactly which records in a campaign could not be created. By initiating and retrieving an export, you will get row-by-row errors for your campaign. For a step-by-step walkthrough of creating a campaign and exporting failures, see our [Campaigns Guide](https://help.lob.com/best-practices/launching-your-first-campaign).  Create an export file associated with an upload.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exportModel"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UploadCreateExport)</returns>
        System.Threading.Tasks.Task<ApiResponse<UploadCreateExport>> create_exportWithHttpInfoAsync(string uplId, ExportModel exportModel, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// upload_file
        /// </summary>
        /// <remarks>
        /// Upload an [audience file](https://help.lob.com/best-practices/campaign-audience-guide) and associate it with an upload.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="file"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UploadFile</returns>
        System.Threading.Tasks.Task<UploadFile> upload_fileAsync(string uplId, Object file, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// upload_file
        /// </summary>
        /// <remarks>
        /// Upload an [audience file](https://help.lob.com/best-practices/campaign-audience-guide) and associate it with an upload.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="file"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UploadFile)</returns>
        System.Threading.Tasks.Task<ApiResponse<UploadFile>> upload_fileWithHttpInfoAsync(string uplId, Object file, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// update
        /// </summary>
        /// <remarks>
        /// Update the details of an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="uploadUpdatable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Upload</returns>
        System.Threading.Tasks.Task<Upload> updateAsync(string uplId, UploadUpdatable uploadUpdatable, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// update
        /// </summary>
        /// <remarks>
        /// Update the details of an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="uploadUpdatable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Upload)</returns>
        System.Threading.Tasks.Task<ApiResponse<Upload>> updateWithHttpInfoAsync(string uplId, UploadUpdatable uploadUpdatable, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// list
        /// </summary>
        /// <remarks>
        /// Returns a list of your uploads. Optionally, filter uploads by campaign.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="campaignId">id of the campaign (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Upload&gt;</returns>
        System.Threading.Tasks.Task<List<Upload>> listAsync(string campaignId = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// list
        /// </summary>
        /// <remarks>
        /// Returns a list of your uploads. Optionally, filter uploads by campaign.
        /// </remarks>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="campaignId">id of the campaign (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Upload&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Upload>>> listWithHttpInfoAsync(string campaignId = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IUploadsApi : IUploadsApiSync, IUploadsApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class UploadsApi : IUploadsApi
    {
        private lob.dotnet.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="UploadsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public UploadsApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="UploadsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public UploadsApi(string basePath)
        {
            this.Configuration = lob.dotnet.Client.Configuration.MergeConfigurations(
                lob.dotnet.Client.GlobalConfiguration.Instance,
                new lob.dotnet.Client.Configuration { BasePath = basePath }
            );
            this.Client = new lob.dotnet.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new lob.dotnet.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = lob.dotnet.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="UploadsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public UploadsApi(lob.dotnet.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = lob.dotnet.Client.Configuration.MergeConfigurations(
                lob.dotnet.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new lob.dotnet.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new lob.dotnet.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = lob.dotnet.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="UploadsApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public UploadsApi(lob.dotnet.Client.ISynchronousClient client, lob.dotnet.Client.IAsynchronousClient asyncClient, lob.dotnet.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = lob.dotnet.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public lob.dotnet.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public lob.dotnet.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public lob.dotnet.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public lob.dotnet.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// get_export Retrieves the details of an existing export. You need only supply the unique export identifier that was returned upon export creation. If you try retrieving an export immediately after creating one (i.e., before we&#39;re done processing the export), you will get back an export object with &#x60;state &#x3D; in_progress&#x60;.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exId">ID of the export</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Export</returns>
        public Export get_export(string uplId, string exId, int operationIndex = 0)
        {
            lob.dotnet.Client.ApiResponse<Export> localVarResponse = get_exportWithHttpInfo(uplId, exId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// get_export Retrieves the details of an existing export. You need only supply the unique export identifier that was returned upon export creation. If you try retrieving an export immediately after creating one (i.e., before we&#39;re done processing the export), you will get back an export object with &#x60;state &#x3D; in_progress&#x60;.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exId">ID of the export</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Export</returns>
        public lob.dotnet.Client.ApiResponse<Export> get_exportWithHttpInfo(string uplId, string exId, int operationIndex = 0)
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->get_export");
            }

            // verify the required parameter 'exId' is set
            if (exId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'exId' when calling UploadsApi->get_export");
            }

            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter
            localVarRequestOptions.PathParameters.Add("ex_id", lob.dotnet.Client.ClientUtils.ParameterToString(exId)); // path parameter

            localVarRequestOptions.Operation = "UploadsApi.get_export";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Export>("/uploads/{upl_id}/exports/{ex_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("get_export", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// get_export Retrieves the details of an existing export. You need only supply the unique export identifier that was returned upon export creation. If you try retrieving an export immediately after creating one (i.e., before we&#39;re done processing the export), you will get back an export object with &#x60;state &#x3D; in_progress&#x60;.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exId">ID of the export</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Export</returns>
        public async System.Threading.Tasks.Task<Export> get_exportAsync(string uplId, string exId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            lob.dotnet.Client.ApiResponse<Export> localVarResponse = await get_exportWithHttpInfoAsync(uplId, exId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// get_export Retrieves the details of an existing export. You need only supply the unique export identifier that was returned upon export creation. If you try retrieving an export immediately after creating one (i.e., before we&#39;re done processing the export), you will get back an export object with &#x60;state &#x3D; in_progress&#x60;.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exId">ID of the export</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Export)</returns>
        public async System.Threading.Tasks.Task<lob.dotnet.Client.ApiResponse<Export>> get_exportWithHttpInfoAsync(string uplId, string exId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->get_export");
            }

            // verify the required parameter 'exId' is set
            if (exId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'exId' when calling UploadsApi->get_export");
            }


            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter
            localVarRequestOptions.PathParameters.Add("ex_id", lob.dotnet.Client.ClientUtils.ParameterToString(exId)); // path parameter

            localVarRequestOptions.Operation = "UploadsApi.get_export";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Export>("/uploads/{upl_id}/exports/{ex_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("get_export", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// get Retrieves the details of an existing upload. You need only supply the unique upload identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Upload</returns>
        public Upload get(string uplId, int operationIndex = 0)
        {
            lob.dotnet.Client.ApiResponse<Upload> localVarResponse = getWithHttpInfo(uplId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// get Retrieves the details of an existing upload. You need only supply the unique upload identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Upload</returns>
        public lob.dotnet.Client.ApiResponse<Upload> getWithHttpInfo(string uplId, int operationIndex = 0)
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->get");
            }

            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter

            localVarRequestOptions.Operation = "UploadsApi.get";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Upload>("/uploads/{upl_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("get", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// get Retrieves the details of an existing upload. You need only supply the unique upload identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Upload</returns>
        public async System.Threading.Tasks.Task<Upload> getAsync(string uplId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            lob.dotnet.Client.ApiResponse<Upload> localVarResponse = await getWithHttpInfoAsync(uplId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// get Retrieves the details of an existing upload. You need only supply the unique upload identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Upload)</returns>
        public async System.Threading.Tasks.Task<lob.dotnet.Client.ApiResponse<Upload>> getWithHttpInfoAsync(string uplId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->get");
            }


            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter

            localVarRequestOptions.Operation = "UploadsApi.get";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Upload>("/uploads/{upl_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("get", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// create Creates a new upload with the provided properties.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadWritable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Upload</returns>
        public Upload create(UploadWritable uploadWritable, int operationIndex = 0)
        {
            lob.dotnet.Client.ApiResponse<Upload> localVarResponse = createWithHttpInfo(uploadWritable);
            return localVarResponse.Data;
        }

        /// <summary>
        /// create Creates a new upload with the provided properties.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadWritable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Upload</returns>
        public lob.dotnet.Client.ApiResponse<Upload> createWithHttpInfo(UploadWritable uploadWritable, int operationIndex = 0)
        {
            // verify the required parameter 'uploadWritable' is set
            if (uploadWritable == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uploadWritable' when calling UploadsApi->create");
            }

            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = uploadWritable;

            localVarRequestOptions.Operation = "UploadsApi.create";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Upload>("/uploads", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("create", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// create Creates a new upload with the provided properties.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadWritable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Upload</returns>
        public async System.Threading.Tasks.Task<Upload> createAsync(UploadWritable uploadWritable, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            lob.dotnet.Client.ApiResponse<Upload> localVarResponse = await createWithHttpInfoAsync(uploadWritable, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// create Creates a new upload with the provided properties.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uploadWritable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Upload)</returns>
        public async System.Threading.Tasks.Task<lob.dotnet.Client.ApiResponse<Upload>> createWithHttpInfoAsync(UploadWritable uploadWritable, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'uploadWritable' is set
            if (uploadWritable == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uploadWritable' when calling UploadsApi->create");
            }


            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = uploadWritable;

            localVarRequestOptions.Operation = "UploadsApi.create";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Upload>("/uploads", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("create", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// delete Delete an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void delete(string uplId, int operationIndex = 0)
        {
            deleteWithHttpInfo(uplId);
        }

        /// <summary>
        /// delete Delete an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public lob.dotnet.Client.ApiResponse<Object> deleteWithHttpInfo(string uplId, int operationIndex = 0)
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->delete");
            }

            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter

            localVarRequestOptions.Operation = "UploadsApi.delete";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/uploads/{upl_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("delete", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// delete Delete an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task deleteAsync(string uplId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await deleteWithHttpInfoAsync(uplId, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// delete Delete an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<lob.dotnet.Client.ApiResponse<Object>> deleteWithHttpInfoAsync(string uplId, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->delete");
            }


            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter

            localVarRequestOptions.Operation = "UploadsApi.delete";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/uploads/{upl_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("delete", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// create_export Campaign Exports can help you understand exactly which records in a campaign could not be created. By initiating and retrieving an export, you will get row-by-row errors for your campaign. For a step-by-step walkthrough of creating a campaign and exporting failures, see our [Campaigns Guide](https://help.lob.com/best-practices/launching-your-first-campaign).  Create an export file associated with an upload.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exportModel"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>UploadCreateExport</returns>
        public UploadCreateExport create_export(string uplId, ExportModel exportModel, int operationIndex = 0)
        {
            lob.dotnet.Client.ApiResponse<UploadCreateExport> localVarResponse = create_exportWithHttpInfo(uplId, exportModel);
            return localVarResponse.Data;
        }

        /// <summary>
        /// create_export Campaign Exports can help you understand exactly which records in a campaign could not be created. By initiating and retrieving an export, you will get row-by-row errors for your campaign. For a step-by-step walkthrough of creating a campaign and exporting failures, see our [Campaigns Guide](https://help.lob.com/best-practices/launching-your-first-campaign).  Create an export file associated with an upload.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exportModel"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of UploadCreateExport</returns>
        public lob.dotnet.Client.ApiResponse<UploadCreateExport> create_exportWithHttpInfo(string uplId, ExportModel exportModel, int operationIndex = 0)
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->create_export");
            }

            // verify the required parameter 'exportModel' is set
            if (exportModel == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'exportModel' when calling UploadsApi->create_export");
            }

            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter
            localVarRequestOptions.Data = exportModel;

            localVarRequestOptions.Operation = "UploadsApi.create_export";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<UploadCreateExport>("/uploads/{upl_id}/exports", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("create_export", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// create_export Campaign Exports can help you understand exactly which records in a campaign could not be created. By initiating and retrieving an export, you will get row-by-row errors for your campaign. For a step-by-step walkthrough of creating a campaign and exporting failures, see our [Campaigns Guide](https://help.lob.com/best-practices/launching-your-first-campaign).  Create an export file associated with an upload.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exportModel"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UploadCreateExport</returns>
        public async System.Threading.Tasks.Task<UploadCreateExport> create_exportAsync(string uplId, ExportModel exportModel, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            lob.dotnet.Client.ApiResponse<UploadCreateExport> localVarResponse = await create_exportWithHttpInfoAsync(uplId, exportModel, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// create_export Campaign Exports can help you understand exactly which records in a campaign could not be created. By initiating and retrieving an export, you will get row-by-row errors for your campaign. For a step-by-step walkthrough of creating a campaign and exporting failures, see our [Campaigns Guide](https://help.lob.com/best-practices/launching-your-first-campaign).  Create an export file associated with an upload.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="exportModel"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UploadCreateExport)</returns>
        public async System.Threading.Tasks.Task<lob.dotnet.Client.ApiResponse<UploadCreateExport>> create_exportWithHttpInfoAsync(string uplId, ExportModel exportModel, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->create_export");
            }

            // verify the required parameter 'exportModel' is set
            if (exportModel == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'exportModel' when calling UploadsApi->create_export");
            }


            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter
            localVarRequestOptions.Data = exportModel;

            localVarRequestOptions.Operation = "UploadsApi.create_export";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<UploadCreateExport>("/uploads/{upl_id}/exports", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("create_export", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// upload_file Upload an [audience file](https://help.lob.com/best-practices/campaign-audience-guide) and associate it with an upload.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="file"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>UploadFile</returns>
        public UploadFile upload_file(string uplId, Object file, int operationIndex = 0)
        {
            lob.dotnet.Client.ApiResponse<UploadFile> localVarResponse = upload_fileWithHttpInfo(uplId, file);
            return localVarResponse.Data;
        }

        /// <summary>
        /// upload_file Upload an [audience file](https://help.lob.com/best-practices/campaign-audience-guide) and associate it with an upload.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="file"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of UploadFile</returns>
        public lob.dotnet.Client.ApiResponse<UploadFile> upload_fileWithHttpInfo(string uplId, Object file, int operationIndex = 0)
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->upload_file");
            }

            // verify the required parameter 'file' is set
            if (file == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'file' when calling UploadsApi->upload_file");
            }

            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter
            localVarRequestOptions.FormParameters.Add("file", lob.dotnet.Client.ClientUtils.ParameterToString(file)); // form parameter

            localVarRequestOptions.Operation = "UploadsApi.upload_file";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<UploadFile>("/uploads/{upl_id}/file", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("upload_file", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// upload_file Upload an [audience file](https://help.lob.com/best-practices/campaign-audience-guide) and associate it with an upload.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="file"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UploadFile</returns>
        public async System.Threading.Tasks.Task<UploadFile> upload_fileAsync(string uplId, Object file, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            lob.dotnet.Client.ApiResponse<UploadFile> localVarResponse = await upload_fileWithHttpInfoAsync(uplId, file, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// upload_file Upload an [audience file](https://help.lob.com/best-practices/campaign-audience-guide) and associate it with an upload.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">ID of the upload</param>
        /// <param name="file"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UploadFile)</returns>
        public async System.Threading.Tasks.Task<lob.dotnet.Client.ApiResponse<UploadFile>> upload_fileWithHttpInfoAsync(string uplId, Object file, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->upload_file");
            }

            // verify the required parameter 'file' is set
            if (file == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'file' when calling UploadsApi->upload_file");
            }


            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "multipart/form-data"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter
            localVarRequestOptions.FormParameters.Add("file", lob.dotnet.Client.ClientUtils.ParameterToString(file)); // form parameter

            localVarRequestOptions.Operation = "UploadsApi.upload_file";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<UploadFile>("/uploads/{upl_id}/file", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("upload_file", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// update Update the details of an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="uploadUpdatable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Upload</returns>
        public Upload update(string uplId, UploadUpdatable uploadUpdatable, int operationIndex = 0)
        {
            lob.dotnet.Client.ApiResponse<Upload> localVarResponse = updateWithHttpInfo(uplId, uploadUpdatable);
            return localVarResponse.Data;
        }

        /// <summary>
        /// update Update the details of an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="uploadUpdatable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Upload</returns>
        public lob.dotnet.Client.ApiResponse<Upload> updateWithHttpInfo(string uplId, UploadUpdatable uploadUpdatable, int operationIndex = 0)
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->update");
            }

            // verify the required parameter 'uploadUpdatable' is set
            if (uploadUpdatable == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uploadUpdatable' when calling UploadsApi->update");
            }

            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter
            localVarRequestOptions.Data = uploadUpdatable;

            localVarRequestOptions.Operation = "UploadsApi.update";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<Upload>("/uploads/{upl_id}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("update", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// update Update the details of an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="uploadUpdatable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Upload</returns>
        public async System.Threading.Tasks.Task<Upload> updateAsync(string uplId, UploadUpdatable uploadUpdatable, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            lob.dotnet.Client.ApiResponse<Upload> localVarResponse = await updateWithHttpInfoAsync(uplId, uploadUpdatable, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// update Update the details of an existing upload. You need only supply the unique identifier that was returned upon upload creation.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="uplId">id of the upload</param>
        /// <param name="uploadUpdatable"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Upload)</returns>
        public async System.Threading.Tasks.Task<lob.dotnet.Client.ApiResponse<Upload>> updateWithHttpInfoAsync(string uplId, UploadUpdatable uploadUpdatable, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'uplId' is set
            if (uplId == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uplId' when calling UploadsApi->update");
            }

            // verify the required parameter 'uploadUpdatable' is set
            if (uploadUpdatable == null)
            {
                throw new lob.dotnet.Client.ApiException(400, "Missing required parameter 'uploadUpdatable' when calling UploadsApi->update");
            }


            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("upl_id", lob.dotnet.Client.ClientUtils.ParameterToString(uplId)); // path parameter
            localVarRequestOptions.Data = uploadUpdatable;

            localVarRequestOptions.Operation = "UploadsApi.update";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PatchAsync<Upload>("/uploads/{upl_id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("update", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// list Returns a list of your uploads. Optionally, filter uploads by campaign.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="campaignId">id of the campaign (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;Upload&gt;</returns>
        public List<Upload> list(string campaignId = default(string), int operationIndex = 0)
        {
            lob.dotnet.Client.ApiResponse<List<Upload>> localVarResponse = listWithHttpInfo(campaignId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// list Returns a list of your uploads. Optionally, filter uploads by campaign.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="campaignId">id of the campaign (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;Upload&gt;</returns>
        public lob.dotnet.Client.ApiResponse<List<Upload>> listWithHttpInfo(string campaignId = default(string), int operationIndex = 0)
        {
            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (campaignId != null)
            {
                localVarRequestOptions.QueryParameters.Add(lob.dotnet.Client.ClientUtils.ParameterToMultiMap("", "campaignId", campaignId));
            }

            localVarRequestOptions.Operation = "UploadsApi.list";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Upload>>("/uploads", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("list", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// list Returns a list of your uploads. Optionally, filter uploads by campaign.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="campaignId">id of the campaign (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Upload&gt;</returns>
        public async System.Threading.Tasks.Task<List<Upload>> listAsync(string campaignId = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            lob.dotnet.Client.ApiResponse<List<Upload>> localVarResponse = await listWithHttpInfoAsync(campaignId, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// list Returns a list of your uploads. Optionally, filter uploads by campaign.
        /// </summary>
        /// <exception cref="lob.dotnet.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="campaignId">id of the campaign (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Upload&gt;)</returns>
        public async System.Threading.Tasks.Task<lob.dotnet.Client.ApiResponse<List<Upload>>> listWithHttpInfoAsync(string campaignId = default(string), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            lob.dotnet.Client.RequestOptions localVarRequestOptions = new lob.dotnet.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = lob.dotnet.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = lob.dotnet.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (campaignId != null)
            {
                localVarRequestOptions.QueryParameters.Add(lob.dotnet.Client.ClientUtils.ParameterToMultiMap("", "campaignId", campaignId));
            }

            localVarRequestOptions.Operation = "UploadsApi.list";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + lob.dotnet.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Upload>>("/uploads", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("list", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
